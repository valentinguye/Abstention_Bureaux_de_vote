---
title: "bureau-de-vote"
author: "valentin"
date: "2025-10-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(here)
library(tidyverse)
library(sf)
library(readxl)
library(xlsx)
library(jsonlite)
library(stringr)
library(DescTools)
library(rnaturalearth)
library(ggpubr)
library(units)
library(scales)
library(kableExtra)

# devtools::install_github("InseeFrLab/mapvotr")
library(mapvotr)

library(leaflet)
library(htmlwidgets)
library(htmltools)  # for HTML rendering in labels
library(RColorBrewer)

```

Objectif : Connaître le taux d'abstention par aire géographique des bureaux de vote (BV) à Marseille. 

Plan d'action : 

- Importer les données du taux d'abstention par BV (au second tour des élections municipales de 2020) issues de : https://www.data.gouv.fr/datasets/municipales-2020-resultats-2nd-tour/

- Importer les données des aires géographiques par BV issues de : https://www.data.gouv.fr/datasets/proposition-de-contours-des-bureaux-de-vote/

- Restreindre les données aux BV de Marseille 

- Joindre les données par un identifiant BV, en s'assurant qu'il est cohérent entre les deux bases. 


```{r, include = FALSE}

# Résultats électoraux, y compris abstention, par BV 
# Source : https://www.data.gouv.fr/datasets/municipales-2020-resultats-2nd-tour/
res_bv = read_xlsx(here("input_data", "resultats-par-niveau-burvot-t2-france-entiere.xlsx"))

# Tous les BV et leur adresse
# Source : https://www.data.gouv.fr/datasets/bureaux-de-vote-et-adresses-de-leurs-electeurs/
bv_reu = read.csv(here("input_data", "table-bv-reu.csv"))

# Toutes les adresses - hyper lourd (16M de lignes)
# ad_reu = read.csv(here("input_data", "table-adresses-reu.csv"))
# maiz = ad_reu %>% filter(grepl("37 rue Smith", geo_adresse))
# arr = ad_reu %>% filter(code_commune_ref == 69002) # bizarre

# Aires géographiques "contours" estimées par l'INSEE pour chaque BV
# Source : https://www.data.gouv.fr/datasets/proposition-de-contours-des-bureaux-de-vote/
contours = read_sf((here("input_data", "contours-france-entiere-latest-v2.geojson")))

# Secteurs des bureaux de vote à *Paris* 
# download.file(
#   "https://www.data.gouv.fr/datasets/secteurs-des-bureaux-de-vote-2025/#/resources/acc452ca-05df-483a-993b-bf9154112031", 
#   destfile = here("input_data", "secteurs-des-bureaux-de-vote-2025.csv"),
#   mode = "wb")
# sect_bv = jsonlite::fromJSON(here("input_data", "secteurs-des-bureaux-de-vote-2025.json"))
# sect_bv = read_json(here("input_data", "secteurs-des-bureaux-de-vote-2025.json"),
#                     simplifyVector = TRUE)
# sect_bv = read_csv(here("input_data", "secteurs-des-bureaux-de-vote-2025.csv"))
# glimpse(sect_bv)
# sect_bv_flt = sect_bv %>% mutate(across(where(is.data.frame), as.character))
# sf_bv = read_sf((here("input_data", "secteurs-des-bureaux-de-vote-2025.geojson")))
# sect_bv %>% st_as_sf(sect_bv, sf_column_name = sect_bv$geo_shape$geometry)

```


```{r, include=FALSE}
# A bit of tidying
# names(res_bv)
res_bv = 
  res_bv %>% 
  rename(nomCommune = `Libellé de la commune`,
         codeBV_inCommune = `Code B.Vote`,
         pct_Abs_in_Ins = `% Abs/Ins`, 
         pct_Vot_in_Ins = `% Vot/Ins`, 
         pct_Blancs_in_Ins = `% Blancs/Ins`, 
         pct_Blancs_in_Vot = `% Blancs/Vot`, 
         pct_Exp_in_Ins = `% Exp/Ins`, 
         pct_Exp_in_Vot = `% Exp/Vot`
         ) %>% 
  mutate(idBV_miomFormat = paste0(`Code du département`, `Code de la commune`, "_", codeBV_inCommune))

# Contours
# names(contours)

# BV addresses
bv_reu = 
  bv_reu %>% 
  rowwise %>% 
  mutate(adresseBV = paste(libelle_reu, num_voie_reu, voie_reu, cp_reu, 
                            sep = " ")) %>% 
  ungroup() %>% 
  mutate(codeBV_inCommune = sub("^[^_]*_", "", id_brut_miom))

```


```{r, include=FALSE}
# Restrict to Marseille 
res_bv_mrs = res_bv %>% filter(nomCommune == "Marseille") # 
# glimpse(res_bv_mrs)

unique_BV_res_bv_mrs = res_bv_mrs$idBV_miomFormat %>% unique() %>% length() # 480
stopifnot(unique_BV_res_bv_mrs == nrow(res_bv_mrs))

contours_mrs = contours %>% filter(nomCommune == "Marseille") # 476 BV
glimpse(contours_mrs)

unique_BV_contours_mrs = contours_mrs$numeroBureauVote %>% unique() %>% length()
unique_BV_contours_mrs
contours_mrs$codeBureauVote %>% unique() %>% length()
contours_mrs$id_bv %>% unique() %>% length()


bv_reu_mrs = bv_reu %>% filter(commune_reu == "marseille")
bv_reu_mrs$id_brut_reu %>% unique() %>% length()
bv_reu_mrs$id_brut_insee %>% unique() %>% length() # this is the id from INSEE, the entity providing the shapefile. 
bv_reu_mrs$id_brut_miom %>% unique() %>% length() # this is the id from the ministère de l'intérieur et des outre-mers, the same entity as the one providing the election data. 


```

# *Methode pour joindre les contours et les résultats des élections par bureau de vote*

En restreignant à Marseille, il y a `r unique_BV_res_bv_mrs` bureaux de vote uniques avec des résultats d'élection. 

Concernant les bureaux de vote avec une aire géographique estimée, il y a `r unique_BV_contours_mrs` identifiants uniques, pour chacun des 3 formats d'identifiants fournis.  

Pour joindre les données de contours et de résultats électoraux, il faut s'assurer qu'on utilise une clé qui identifie les mêmes BV dans chaque base de données.
Les résultats électoraux sont fournis par le MIOM, sans explication sur l'identifiant BV.
Les contours sont fournis par l'INSEE, sans explication sur LES identifiants BV.
Par contre, l'INSEE fournit une table de correspondance entre différents identifiants BV, avec une documentation. 
https://www.data.gouv.fr/datasets/bureaux-de-vote-et-adresses-de-leurs-electeurs/

Cette documentation indique que la variable id_brut_miom est l'"identifiant unique dans le système d’information centralisant les résultats électoraux
du ministère de l’Intérieur (SIE1) du bureau de vote associé à l’adresse" et est "Construit comme suit : code-commune-ref_code-miom-du-bv-dans-la-commune." (appelons le le format MIOM). 
En utilisant cet identifiant comme clé, on peut donc déjà joindre avec confiance la table d'équivalence de l'INSEE avec la base des résultats électoraux du MIOM. 

Ensuite, on se sert des équivalences pour ajouter les contours. 

Grâce à la documentation de la table d'équivalence, on comprend que dans contours, il y a deux identifiants distincts: 

- codeBureauVote au format codeDepartementcodeCommune_numeroBureauVote ("format MIOM")

- id_bv qui concatenne un autre format de code département-commune et une version "nettoyée" du numéro de bureau de vote ("format REU / INSEE").

Comme chacun de ces formats est présent dans table d'équivalence, on peut joindre une fois par chacun comme clé. Si on obtient le même résultat, on peut avoir confiance dans la jointure entre les résultats électoraux et contours.   

```{r, include=FALSE}
# Join election results to equivalence table
# Use inner_join to be more restrictive about the matches (do not leave unmatched instances in the left)
res_eq = 
  inner_join(res_bv_mrs, 
            bv_reu_mrs, 
            by = join_by(idBV_miomFormat == id_brut_miom))

# bv_reu_mrs$id_brut_insee %>% anyNA()
# res_eq$id_brut_insee %>% anyNA()
# res_eq %>% filter(is.na(id_brut_insee))

# Join to contours, based on a priori MIOM format in both sides
# (contours has 476 rows, so 2 instances less)
fin = 
  inner_join(contours_mrs, 
            res_eq %>% select(adresseBV, idBV_miomFormat, contains("id_brut_") | contains("Abs") | contains("pct")), 
            by = join_by(codeBureauVote == idBV_miomFormat))

# Check that we get the same matches based on a merge in the other key
test = 
   inner_join(contours_mrs, 
             res_eq %>% select(adresseBV, idBV_miomFormat, contains("id_brut_") | contains("Abs") | contains("pct")), 
             by = join_by(id_bv == id_brut_insee))

stopifnot(all.equal(
  test %>% mutate(testvar = as.numeric(numeroBureauVote)*Abstentions) %>% pull(testvar), 
  fin  %>% mutate(testvar = as.numeric(numeroBureauVote)*Abstentions) %>% pull(testvar)
))

# ____________________________________
# Donc le pb vient déjà de là, où le match n'est en fait pas parfait, et les 2 obs. dans res_bv_mrs ne matchent pas avec bv_reu_mrs.
# (et donc ne récupère ps les id_brut_)  
# Mais en fait c'est les deux qui sont dans res_bv_mrs mais pas dans bv_reu_mrs.
# 
# # Apparemment test prend des NAs d'Abstentions alors que fin n'en prend pas. Donc test ne match pas aussi bien. 
# codeBVpb = test %>% filter(is.na(Abstentions)) %>% pull(codeBureauVote)
# id_BVpb = test %>% filter(is.na(Abstentions)) %>% pull(id_bv)
# 
# contours_pb = contours_mrs %>% filter(codeBureauVote %in% codeBVpb) 
# contours_pb$id_bv
# 
# res_eq %>% filter(id_brut_insee %in% id_BVpb) 
# res_eq_pb = res_eq %>% filter(idBV_miomFormat %in% codeBVpb) 
#   
# res_eq %>% filter(idBV_miomFormat %in% codeBVpb) %>% View()
# 
# pb = test %>% filter(is.na(Abstentions)) 
# 
# sinpb = fin %>% filter(!codeBureauVote %in% codeBVpb)
# stopifnot(all.equal(
#   test %>% mutate(testvar = as.numeric(numeroBureauVote)*Abstentions) %>% pull(testvar), 
#   sinpb  %>% mutate(testvar = as.numeric(numeroBureauVote)*Abstentions) %>% pull(testvar)
# ))

# check match quality 
# res_bv_mrs$codeBV %>% is.na() %>% sum()
# res_bv_mrs$Abstentions %>% class()
# res_bv_mrs$Abstentions %>% is.na() %>% sum()
# fin$Abstentions %>% is.na() %>% sum()
# # stopifnot(sum(is.na(fin$Abstentions)) == sum(is.na(res_bv_mrs$Abstentions)))
# # It this passes, they all have a match 
# stopifnot(nrow(fin) <= nrow(contours_mrs))
# # If this passes, they have a unique match
# ____________________________________

# (/!\ SI ON JOINT DES BASES COUVRANT PLUSIEURS COMMUNES IL FAUT PAS UTILISER JUSTE LE CODE BV AU SEIN DE LA COMMUNE COMME CLE)

```
Pour `r nrow(fin)` BVs on a une correspondance fiable entre les données de résultats électoraux du MIOM et les contours de l'INSEE. 

On a utilisé la "Table de correspondance expérimentale et ponctuelle des référentiels de bureaux
de vote" proposée par l'Insee et l'Etalab et la documentation associée (dictionnaire-donnees-bv.pdf et methodology.pdf Annexe B. à ce lien : https://www.data.gouv.fr/datasets/bureaux-de-vote-et-adresses-de-leurs-electeurs/) afin vérifier la crédibilité de la correspondance entre les identifiants dans les deux bases à apairer. 


# CARTE DE L'ABSTENTION AUX ELECTIONS MUNICIPALES DE 2020 PAR BUREAU DE VOTE A MARSEILLE  
```{r}
field_name = "pct_Abs_in_Ins"
# adresse_field <- "adresseBV"

fin$val_formatted <- ifelse(
  is.na(fin[[field_name]]),
  NA_character_,
  paste0(formatC(fin[[field_name]], format = "f", digits = 1, big.mark = " "),
         " %")
)

# Create an HTML label column (one label per feature)
fin$label_html <- 
  # HTML( # Using HTML is necessary to read html terms like <br/>, but it un-vectorizes the column and thus prints all values of the column in each tooltip (hover box). Hopefully, for some reason, using html terms in popup and not in label (in addPolygons) works well without having to convert with HTML...  
  paste0(
  "<strong>Abstention: </strong>", fin$val_formatted, "<br/>",
  "<strong>Adresse BV : </strong>", fin$adresseBV, "<br/>",
  "ID BV MIOM: ", fin$codeBureauVote
# )
)

# fin$label_html %>% head()


# 3. Create a color palette based on that field
pal <- colorNumeric(palette = "YlOrRd", domain = fin[[field_name]], na.color = "transparent")

# 4. Build the leaflet map using the precomputed label column
m <- leaflet(fin) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~pal(get(field_name)), # get() here is fine because field_name is a single string
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.4,   # increased transparency
    highlightOptions = highlightOptions(
      weight = 2,
      color = "#666",
      fillOpacity = 0.6,
      bringToFront = TRUE
    ),
    popup = ~fin$label_html,
    popupOptions = popupOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "13px",
      direction = "auto"
    )
  ) %>%
  addLegend(
    pal = pal,
    values = ~get(field_name),
    opacity = 0.7,
    title = "% d'abstention :",
    position = "bottomright"
  )

# 5. Display the map in RStudio viewer
m

# add title
m_titled <- htmlwidgets::prependContent(
  m,
  htmltools::tags$h3("Carte des taux d'abstention au 2nd tour des élections municipales de 2020 par bureau de vote")
)

# 6. Save it as an interactive HTML file
saveWidget(m_titled, file = here("map_abstention_bv_marseille.html"), selfcontained = TRUE)

```

